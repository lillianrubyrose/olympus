use std::path::Path;
use std::{fs::OpenOptions, io::Write, path::PathBuf};

use crate::{
	generator::{rust::RustCodeGenerator, CodeGenerator},
	verify_src,
};
use eyre::eyre;
use olympus_parser::Parser;

use super::{ensure_is_file, get_filename, CompileLanguage, NamingConventionConfig};

const GENERATED_COMMENT: &str = "/-- THIS FILE WAS AUTOMATICALLY GENERATED BY OLYMPUS --\\";

pub fn run(
	input: PathBuf,
	output: PathBuf,
	language: CompileLanguage,
	overwrite: bool,
	rs_crate: bool,
	rs_crate_name: &Option<String>,
	naming_convention_config: &NamingConventionConfig,
) -> eyre::Result<()> {
	ensure_is_file(&input)?;

	let filename = get_filename(&input)?;
	let src = std::fs::read_to_string(input)?;
	let Some(parser) = verify_src(&src, &filename) else {
		return Ok(());
	};

	match language {
		CompileLanguage::Rust => {
			gen_rust(
				&parser,
				output,
				overwrite,
				rs_crate,
				rs_crate_name,
				naming_convention_config,
			)?;
		}
	}

	println!("Compiled!");

	Ok(())
}

fn gen_rust(
	parser: &Parser,
	output: PathBuf,
	overwrite: bool,
	gen_crate: bool,
	gen_crate_name: &Option<String>,
	naming_convention_config: &NamingConventionConfig,
) -> eyre::Result<()> {
	if gen_crate {
		return if let Some(crate_name) = gen_crate_name {
			gen_rust_crate(parser, &output, crate_name, overwrite, naming_convention_config)
		} else {
			Err(eyre!("Must specify crate name. (TIP: --rs-crate-name=<name>)"))
		};
	}

	if output.is_dir() {
		return Err(eyre!("You cannot output compiled source to a directory"));
	}

	if output.exists() && !overwrite {
		return Err(eyre!(
			"Output file exists, specify --overwrite if you want to overwrite existing files."
		));
	}

	let mut models_src = String::with_capacity(4096);
	RustCodeGenerator.generate_models(parser, &mut models_src, naming_convention_config);

	let mut output_file = OpenOptions::new()
		.write(true)
		.truncate(true)
		.create(true)
		.open(output)?;
	output_file.write_all(models_src.as_bytes())?;

	Ok(())
}

fn gen_rust_crate(
	parser: &Parser,
	output_dir: &Path,
	crate_name: &str,
	overwrite: bool,
	naming_convention_config: &NamingConventionConfig,
) -> eyre::Result<()> {
	if !output_dir.is_dir() {
		return Err(eyre!("Output must be a directory for crate generation."));
	}

	let mut models_src = String::with_capacity(4096);
	RustCodeGenerator.generate_models(parser, &mut models_src, naming_convention_config);

	let crate_path = output_dir.join(crate_name);
	if crate_path.exists() {
		if !crate_path.is_dir() {
			return Err(eyre!(
				"Your output directory contains a non-directory that conflicts with the crate name '{crate_name}'."
			));
		}

		if overwrite {
			std::fs::remove_dir_all(&crate_path)?;
		} else {
			return Err(eyre!(
				"Crate path exists, specify --overwrite if you want to overwrite existing files."
			));
		}
	}

	std::fs::create_dir_all(&crate_path)?;

	let cargo_toml_path = crate_path.join("Cargo.toml");
	std::fs::write(
		cargo_toml_path,
		format!(
			"[package]
name = \"{crate_name}\"
edition = \"2021\"
version = \"0.0.0-OLYMPUS-GENERATED\"
publish = false

[dependencies]
olympus-net-common.workspace = true
olympus-server.workspace = true
"
		),
	)?;

	let src_path = crate_path.join("src");
	std::fs::create_dir(&src_path)?;

	let src_lib_path = src_path.join("lib.rs");
	std::fs::write(
		src_lib_path,
		format!("// {GENERATED_COMMENT}\npub mod models;\npub mod server;"),
	)?;

	let src_models_path = src_path.join("models.rs");
	let mut models_src = String::with_capacity(4096);
	RustCodeGenerator.generate_file_header(&mut models_src);
	RustCodeGenerator.generate_models(parser, &mut models_src, naming_convention_config);
	RustCodeGenerator.generate_file_footer(&mut models_src);
	std::fs::write(src_models_path, format!("// {GENERATED_COMMENT}\n{models_src}"))?;

	let src_server_path = src_path.join("server.rs");
	let mut server_src = String::with_capacity(4096);
	RustCodeGenerator.generate_file_header(&mut server_src);
	server_src.push_str("use crate::models::*;\n");
	RustCodeGenerator.generate_abstract_server_impl(&parser.rpc_container, &mut server_src, naming_convention_config);
	RustCodeGenerator.generate_server_registration_fn(&parser.rpc_container, &mut server_src, naming_convention_config);
	RustCodeGenerator.generate_file_footer(&mut server_src);
	std::fs::write(src_server_path, format!("// {GENERATED_COMMENT}\n{server_src}"))?;

	Ok(())
}
